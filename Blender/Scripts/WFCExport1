import bpy
import bmesh
import mathutils
import math
from mathutils import Vector, Matrix
from mathutils.geometry import intersect_point_quad_2d
from mathutils.geometry import intersect_point_tri_2d
from mathutils.geometry import distance_point_to_plane

MESH_NAME = "Triangle"
debug = False

# Get a list of all objects in the scene
all_objects = bpy.context.selected_objects

def create_redmarker(co, name):
    # Create a new sphere mesh
    mesh = bpy.data.meshes.new("Sphere")
    sphere = bpy.data.objects.new((name + "Sphere"), mesh)

    # Set the sphere's location
    sphere.location = (co)

    # Add the sphere to the scene
    scene = bpy.context.scene
    scene.collection.objects.link(sphere)

    # Create a new material and set its color to red
    material = bpy.data.materials.new(name="Red")
    material.diffuse_color = (1.0, 0.0, 0.0, 1.0)  # (R, G, B, A)

    # Assign the material to the sphere
    sphere.data.materials.append(material)

    # Add a subdivision surface modifier to make the sphere smoother
    subsurf_modifier = sphere.modifiers.new(name="Subdivision", type="SUBSURF")
    subsurf_modifier.levels = 2  # Increase the number of subdivisions

    # Set the sphere's radius
    sphere.scale = (0.1, 0.1, 0.1)  # Set the scale to adjust the sphere's size

def compare_vertices(v1,v2):
    if v1.x != v2.x:
        return false
    if v1.y != v2.y:
        return false
    if v1.z != v2.z:
        return false
    return true

def create_referenceobject():
    # Create a new mesh data block
    mesh = bpy.data.meshes.new("ReferenceMesh")

    # Create a new bmesh to add geometry
    bm = bmesh.new()

    # Create the vertices for the bottom triangle
    v1 = bm.verts.new((0.0, 0.0, 0.0))
    v2 = bm.verts.new((1.0, 0.0, 0.0))
    v3 = bm.verts.new((0.5, 0.866, 0.0))

    # Create the vertices for the top triangle
    v4 = bm.verts.new((0.0, 0.0, 1.0))
    v5 = bm.verts.new((1.0, 0.0, 1.0))
    v6 = bm.verts.new((0.5, 0.866, 1.0))

    # Create the bottom triangle face
    f1 = bm.faces.new((v1, v2, v3))

    # Create the top triangle face
    f2 = bm.faces.new((v4, v5, v6))

    # Create the side faces
    f3 = bm.faces.new((v1, v4, v6, v3))
    f4 = bm.faces.new((v6, v3, v2, v5))
    f5 = bm.faces.new((v1, v2, v5, v4))
    
    # Update the bmesh and create a new object from the mesh data
    bm.to_mesh(mesh)
    mesh.update()
    obj = bpy.data.objects.new("ReferenceObject", mesh)
    
    # Get the mesh data
    mesh = obj.data

    ### Set the origin to the volumes center
    center = sum((v.co for v in mesh.vertices), Vector()) / len(mesh.vertices)

    # Move the object to the origin
    obj.location = center

    # Move the mesh data to the origin
    mesh.transform(Matrix.Translation(-center))

    # Set the origin of the object to the center of the mesh
    bpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='MEDIAN')
    
    ### Move the object to the 0,0,0
    # Calculate the center of the mesh
    center = Vector((0.0, 0.0, 0.0))
    for v in mesh.vertices:
        center += obj.matrix_world @ v.co
    center /= len(mesh.vertices)

    # Set the origin to the center of the mesh
    obj.matrix_world.translation = -center 
      
    ### Debug_Only: Show in the scene  
    # Link the object to the scene and make it active
    if debug == True:
        scene = bpy.context.scene
        scene.collection.objects.link(obj)
    
    return obj


def find_connections(obj, referenceObject):
    field = bmesh.new()
    field.from_mesh(obj.data)
    
    reference = bmesh.new()
    reference.from_mesh(referenceObject.data)
    print(field.verts)    
    print(reference.verts)
    
    connections = []
    
    for face in reference.faces:
        collision_points = []
            
        print(len(field.verts))  
          
        for vertOfField in field.verts:
            print("Check Vertex {}", vertOfField.co)
                        
            # first check, calculate distance to plane, must be 0           
            distancePointToPlane = distance_point_to_plane(vertOfField.co, face.verts[0].co, face.normal)
            print(distancePointToPlane)
            
            # distance must be 0 or within a certain range -0.1 to +0.1
            if (distancePointToPlane < 0.1 and distancePointToPlane > -0.1): # find a better value for this          
                insideFace = 0
                
                # second check, check if point is within face
                if len(face.verts) == 4:
                    insideFace = intersect_point_quad_2d(vertOfField.co, face.verts[0].co,face.verts[1].co,face.verts[2].co,face.verts[3].co)
                             
                if len(face.verts) == 3:
                    insideFace = intersect_point_tri_2d(vertOfField.co,face.verts[0].co,face.verts[1].co,face.verts[2].co)
                
                if (insideFace == 1) and (vertOfField.co not in collision_points):
                    collision_points.append(vertOfField.co)
                
        # debug only: Print the collision points
        if debug == True:
            for point in collision_points:
                create_redmarker(point, "face"+str(face.index))
                print(point)
        
        # add the found connections to the collection 
        if len(collision_points) > 0:
            connections.append(collision_points)  
    
    # return connections
    return connections          
    
    
referenceObject = create_referenceobject()

# Loop through each object in the scene
for obj in all_objects:
    
    # Check if the object's name starts with "triangle"
    if obj.name.startswith(MESH_NAME):
        # Output name of Triangle
        print("Found Mesh:", obj.name)
        
        connections = find_connections(obj, referenceObject)
        print("Found connections: ",len(connections))
        print(connections)
        
        
        #get_horizontal_boundaries(copy)
        
        # Get the mesh data for the object
        mesh = obj.data
        
        # Loop through each vertex in the mesh
        for vert in mesh.vertices:
            # Get the local location of the vertex
            loc = obj.matrix_world @ vert.co
            
            # Output the name of the mesh and the local location of the vertex
            #print("Mesh:", obj.name, "Vertex:", vert.index, "Location:", loc)
